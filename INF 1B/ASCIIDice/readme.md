# Project structure #

It is vital the project is structured properly and has been opened correctly
in `IntelliJ`. Generically, projects are conventionally structured like this:

```
NameOfProject    <--- project root directory
├───.idea        <--- IntelliJ files go somewhere under here
├───out          <--- compiled .class files go somewhere under here
└───src          <--- .java files must go here
```

However this project is configured like this:

```
NameOfProject    <--- project root directory
├───.idea        <--- IntelliJ files go somewhere under here
├───modelInput   <--- Sample input files for self-testing 
├───modelOutput  <--- Model output files corresponding to the sample input
├───out          <--- .class files go somewhere under here
└───src          <--- .java files must go here
```

## Check you are off to the right start ##

1. If not already open, activate the `Project` view tab (typically in the
   top-left) by clicking on the tab or for better productivity use the
   short-cut key `Alt+1`
2. Check your project structure is compliant with the diagram; if not you
   may need to re-unpack the `zip` file or open the project in a different way
3. While you are here, it is useful to activate the `Structure` tab
   (typically in the bottom-left) with the short-cut key `Alt+7`. This
   facilitates finding and editing the relevant parts of your code.

## Setting and changing command-line arguments ##

To set the command-line arguments (also known as command-line parameters)
you need to edit your program's run configuration. Although you can create a
run configuration from scratch it is easier to let IntelliJ do it for you:

1. `Run > Edit Configurations...`
2. Choose the name of your program from the left-hand list of Applications
   (the likelihood is IntelliJ will already have selected it)
3. Add your command-line arguments to the line that reads `Program arguments`
4. `OK` the dialogue box and re-run your program
5. Use this same method every time you wish to change the command-line arguments

## Setting and changing input ##

Programs can read input from the keyboard. But this is tedious, slow, and
unreliable for testing because you have to try to type exactly the same things
in exactly the same order every time. A massive improvement on these counts
comes from using the contents of a pre-written file instead. This is known as 
"redirecting the input" or "input redirection." There is a related mechanism 
for redirecting your program's output to a file, see `Saving program output to 
a file`.

IntelliJ can take the contents of a text file and make your program think it
is reading the keyboard:

1. `Run > Edit Configurations...`
2. Choose the name of your program from the left-hand list of Applications
   (the likelihood is IntelliJ will already be selected it)
3. `Modify Options` (`Alt+M`)
4. `Redirect input`
5. `Redirect input from` line will appear in the dialogue
6. Click the folder icon at the end of that line
7. Navigate to the appropriate file that you want to use an input

### Time saver ###

If you want to change which file is taken as input, you need to repeat the
process. Alternatively, there is a file called `yourInput.txt` which you can
leave as the input file. Open that file in IntelliJ and paste in the
contents from another file. Edit to suit your needs. This is a great
time-saver.

You also need reliability in testing, so for that use the provided files or
create your own, for example by merging the contents of multiple other test
files. This is important for reliability because the contents of those files
should not have changed. The provided sample input files are read-only to
help guarantee this.

## Provided sample input files ##

**You can and probably should make your own test files.** Sample input files for
self-testing your work are in the `modelInput` directory. The provided files are
named according to the
following convention: `direction-level-shortDescription.txt`

Notes:

- the three components are separated by a single hyphen;
- the `shortDescription` uses
  [`camelCase`](https://en.wikipedia.org/wiki/CamelCase);
- this naming convention allows the filename to be split into its three
  components by using `-` as the separator providing the `shortDescription`
  avoid using hyphens, hence camelCase.

| **Direction** | **Meaning**                    |
|:--------------|:-------------------------------|
| input         | Send to your program           |
| output        | Generated by the model program |

| **Level** | **Meaning**                                           |
|:----------|:------------------------------------------------------|
| core      | A complete program must handle all these              |
| defensive | Faulty input to test your program's added resilience  |
| extra     | For if you want to go beyond the basic specifications |

There is also a file called `descript.ion` which matches filenames to brief
descriptions.

## Saving program output to a file ##

Sample output files for self-testing your work are in the `modelOutput`
directory. See the section on sample input for an explanation of file names.

Your program should be configured to save its output to
`yourOutput.txt` in the root directory of the project:

1. `Run > Edit Configurations...`
2. Choose the name of your program from the left-hand list of Applications
   (the likelihood is IntelliJ will already be selected it)
3. `Modify Options` (`Alt+M`)
4. `Save console output to file` (a `Logs` section appears near the bottom
   of the dialogue box)
5. Click the folder icon at the end of the line in the `Logs` section that says
   `Save console output to file`
6. Navigate to the `yourOutput.txt` file
7. `OK` the dialogue box

If you have `yourOutput.txt` open in IntelliJ, it will automatically update
when the contents have changed, though the Java program will have to terminate
first.

See the next section on `Comparing output`.

## Comparing output with the model answer ##

It can be hard to spot differences between the required model output and your
program's actual output. To help you there are tools related to
"diff" (for "difference"). IntelliJ has a visual diff tool built-in.

First, ensure your program is saving its output to a file, see `Saving
program output to a file`.

In the `Project` view, right-click `yourOutput.txt` and choose
`Compare With...` (`Ctrl+D`) and select the appropriate equivalent file from
the `modelOutput` directory. This opens a comparison window that shows you the
differences and is configurable for sensitivity to some types of difference such
as spaces and blank lines.

# Design for a simple way to print a dice face #

**Note:** this design is simple but it is not a "good" design. Use the document
on Code Quality to help you see why. Hint: the amount of code in one place,
DRY programming, and the potential reusability and flexibility of the design
&mdash; or rather the lack of these.

Nevertheless, this design serves a useful purpose as a starting point because it
has the minimum amount of complexities. After having designed a program, get the
core part working in a simple way and then build from there by making code more
flexible and robust and by moving it into new places such as new methods.

## Stages ##

Only use the `main` method to:

1. input a `String`
2. convert `String` to an `int`
3. print appropriate face according to the value of that `int`

...in that order.

## Essential components ##

Find a way to:

1. print a line in a platform-independent way &mdash; this matters because Java
   programs are supposed to be portable to other operating systems
2. convert a `String` to an `int`
3. read the command-line arguments
4. a way to test equality between what the user wants printing and the
   correct piece of code to do that printing
5. represent each face of the dice

## Additional components ##

1. use `o` to represent a dot and ` ` to represent no dot
2. use `|` for the vertical (left and right) sides of the face
3. use `-` for the horizontal (top and bottom) sides

## Simplest ##

Core of printing the face of the number 1:

```
if (value is 1) {
        // print face 1
}
```

Repeat for the others and find a way to join those `if`s

## Possible variations ##

1. `if` without `else`
2. `switch` instead of `if ... else`
3. read from the keyboard (or a file) instead of using
   the command-line arguments
4. factor out common commands such as printing the top and bottom so that
   these occur fewer times

# Where to start

Check the `TODO` tab for further instructions.

In this task, you are going to turn a design into a program.
When you do start coding, take baby steps: write up to 3 lines then
test what you have written.

A good place to start is with the hardest part but that requires experience in
knowing what the hardest part is likely to be. One reason for starting with the 
hardest part is that if you can't get that to work, the rest of the program is
essentially pointless. However, as you are learning, writing any part of a
program is still valuable.

You can instead start with the "easiest" part if that helps give you confidence.

Another useful technique is end-to-end development: identify the different
stages, for example:

1. receiving input
2. processing input (handling "bad" input can be more stages)
3. passing the input to another part of the program
4. acting on the input to do something (this can be further split into stages)
5. producing some output

Then get something working, no matter how basic or limited, for each stage.
You can do the stages in any order, though often you work from the last
stage forwards, that way you know what information, data, or input a stage
needs from the components earlier in the system.

Don't try to solve every problem at once. Keep each new thing you add simple,
then test it. Once it's definitely (or probably) working, you can make it
more flexible. One way to do this is to hard-code values, then turn those
into variables, then change where the variable receives its value. For
example, for a program to print the face of a die:

1. start by printing a single die face (let's pick the face for number&nbsp;1)
   &mdash; doing this also means you have proven that the program can
   definitely work, albeit in a currently limited way
2. adapt that code so that it is getting the "picture" to print the face for
   number&nbsp;1 from another place in the code: this could be from another
   method or directly from a data structure &mdash; in either case hard code
   it just to provide the data for printing the face for the number&nbsp;1
3. create the code that receives, prepares, and checks input (this is
   actually several steps) though initially hard code it to produce an `int`
   with a value of `1` and later adapt it to convert a `String` with the
   value `"1"` to an `int`
4. pass that input (genuine or hard-coded) to the code that initiates printing
5. adapt the program so that it takes real input, even though it currently
   only accepts the value `"1"`
6. you now have an end-to-end program, and you can extend its functionality
   in whatever order you feel is appropriate, though printing more dice
   faces and eventually all of them is probably the most advisable route

This is general advice about the process of coding. Don't start by coding as
that's usually the slowest and most error-prone method. Instead, have at least
two designs on paper and think about the relative merits of each design compared
with the other designs. Try to make your designs substantially different rather
being minor variations of each other.

In this pathway, you are given the designs, but you should still consider
drawing them yourself as it helps you understand the designs. If you feel
confident you can then consider how those designs might be changed.
Alternatively code them as they are, then look at tweaking or even radically
altering the designs.

<STYLE>
* {
  font-size:   1.1rem;
  /*font-size:   1.2rem;*/
  background-color: #2A252A;
  color:            #D5DAD5;
  /*background-color: DarkSlateGray;*/
  /*color:            AntiqueWhite;*/
  /*background-color: black;*/
  /*color: white;*/
  /*background-color: white;*/
  /*color: black;*/
}
body {
  width: 80%;
  font-family: "OpenDyslexic", serif;
  /*font-family: sans-serif;*/
  line-height: 180%;
  /*line-height: 200%;*/
}
pre,
code,
pre code {
  font-family: "OpenDyslexicMono", monospace;
  line-height: 150%;
}
ol,
ol ol,
ol ol ol {
  list-style-type: decimal;
}  
em {
  font-style: normal;
  border-bottom-style: solid;
  border-bottom-width: 1px;
  padding-bottom:      2px;
  /*text-decoration: underline;*/
  text-decoration-skip-ink: auto;
}
h2 {
  border-top:  1px solid #D5DAD5;
  margin-top:  80px;
  padding-top: 20px;
}
</STYLE>